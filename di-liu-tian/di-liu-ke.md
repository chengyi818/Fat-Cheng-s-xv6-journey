# 第六课 虚拟内存

## 提纲
1. 地址空间
2. 分页硬件

## 虚拟内存概览

### 虚拟内存要解决什么问题?
考虑这样一个问题,如果shell出现了bug:可能向随机的内存地址写数据.这时候我们必须保护内核和其他进程不被破坏,我们要怎么做?

### 解决方案: 隔离内存空间
1. 每个进程有专属于自己的内存空间
2. 进程可以读写自己的内存
3. 进程不能读写其他进程的内存或者内核内存空间

面临的挑战: 如何在一块物理内存上,实现这样的隔离.

### 分页硬件
1. xv6, jos甚至是Linux kernel都是通过x86提供的硬件分页功能,实现了内存隔离.
2. 分页硬件本质上是提供了一种间隔寻址的功能.
```
  CPU -> MMU -> RAM
      VA     PA
```
3. 软件或者更直接一点CPU执行指令操作的都是虚拟地址,而不是物理地址.
4. 内核在MMU中为每个进程分别保存了虚拟地址和物理地址的对应关系.
5. MMU本质上就是一个表,索引是虚拟地址,值是一个特定结构,被称为*page table*.
6. 通过MMU的flags标志位,可以限制每个进程能够访问的内存空间.

### x86分页大小
1. 每页大小为: 4KB.
2. 内存地址都是4KB对齐的
3. 因此*page table*可以使用虚拟地址中的前20bit就可以定位一个内存页.

### PTE的组成
1. 参考资料: x86_translation_and_registers.pdf
2. 

