# 第六课 虚拟内存

## 提纲
1. 地址空间
2. 分页硬件

## 虚拟内存概览

### 虚拟内存要解决什么问题?
考虑这样一个问题,如果shell出现了bug:可能向随机的内存地址写数据.这时候我们必须保护内核和其他进程不被破坏,我们要怎么做?

### 解决方案: 隔离内存空间
1. 每个进程有专属于自己的内存空间
2. 进程可以读写自己的内存
3. 进程不能读写其他进程的内存或者内核内存空间

面临的挑战: 如何在一块物理内存上,实现这样的隔离.

### 分页硬件
1. xv6, jos甚至是Linux kernel都是通过x86提供的硬件分页功能,实现了内存隔离.
2. 分页硬件本质上是提供了一种间隔寻址的功能.
```
  CPU -> MMU -> RAM
      VA     PA
```
3. 软件或者更直接一点CPU执行指令操作的都是虚拟地址,而不是物理地址.
4. 内核在MMU中为每个进程分别保存了虚拟地址和物理地址的对应关系.
5. MMU本质上就是一个表,索引是虚拟地址,值是一个特定结构,被称为*page table*.
6. 通过MMU的flags标志位,可以限制每个进程能够访问的内存空间.

### x86分页大小
1. 每页大小为: 4KB.
2. 内存地址都是4KB对齐的
3. 因此*page table*可以使用虚拟地址中的前20bit就可以定位一个内存页.

### PTE的组成
1. 参考资料: x86_translation_and_registers.pdf
2. PTE前20bit代表对应页的物理地址,也被称为*physical page number*,简写为PPN.
3. MMU在将虚拟地址转换为物理地址的过程中,会将前20位虚拟地址替换为PPN.
4. 低位的12bit是标志位,表示存在,可写,用户进程是否可以访问等等.

### 如果页表仅由PTE组成,是否可行?
我们来计算这样一个页表的大小:
1. 索引项总数为2^20, 每项大小32bit.总计消耗内存为4MB.
2. 这对于早期的计算而已,消耗太大.
3. 事实上,这样的设计存在巨大的浪费.因为很多程序仅仅需要分配数百页内存.没必要在一开始就分配这么大的页表.

### x86 二级页表
1. 第一级是*page directory*(PD),简写为PDE.
2. PDE本身组成一个1024*32的表,一共占用4KB内存.
3. PDE高20位为PPN,指向一个PTE表.低12位为标志位.
4. 正是因为PDE存在标志位,因此可以节约PTE表的空间.
5. PTE表同样是一个1024*32的表,每个索引项可以指向1个内存页.






















---
