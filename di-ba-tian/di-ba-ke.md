# 第八课 系统调用, 中断, 异常

## 第七课 课后作业
[添加CPU alarm](https://pdos.csail.mit.edu/6.828/2017/homework/xv6-alarm.html)

##提示
有三个注意点:
1. 添加一个新的系统调用
2. 通过时间中断,来计算程序已经运行的时间.
3. 内核回调注册函数.

### 添加系统调用
```
  syscall.h: #define SYS_alarm 22
  usys.S: SYSCALL(alarm)
    alarmtest.asm -- mov $0x16,%eax -- 0x16 is SYS_alarm
  syscall.c syscalls[] table
  sysproc.c sys_alarm()
```
注意这里,由于我们之前添加了date系统调用,因此我使用的系统调用号为23.

本质上, `alarm`是希望实现从用户空间`alarm()`函数到内核`sys_alarm()`函数的调用.由于进程隔离的需要,因此我们必须使用一种间接的调用方法.也就是中断的方式.


### sys_alarm 处理
1. 内核处理系统调用时,是通过trapframe->eax寄存器中的内容,来判断用户空间调用的具体系统调用.
2. `sys_alarm`是通过访问用户空间栈来获取系统调用所需的参数内容.

### 处理时钟中断
1. 检查剩余时间
2. 如果超时,则回调注册函数.
3. 重置剩余时间.
4. 时钟中断号`IRQ_TIMER`.

### 回调注册函数
1. 在内核中,通过操作用户空间函数栈的方式来调用注册函数.
2. 将esp指针下移,将当前eip保存.
3. 将eip指向注册函数.


## Q&&A
1. 新的`trap()`实现中有什么安全问题?
2. 为什么不能直接在内核中调用注册函数?
3. 如果回调时,没有保存当前eip,会怎么样?
4. 为什么需要检查CPL为3?
  在内核中处理中断时,依然会产生中断.
5. 如果用户空间注册函数指向了内核地址,会怎么样?
  在从内核返回用户空间后,eip取指时,MMU将会检查权限.


## 中断

### 主题
1. 硬件希望获得关注.
2. 因此,软件不得不放下手头的工作并且回应硬件.

### 陷阱门从何而来?
