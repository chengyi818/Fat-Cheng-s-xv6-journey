# 栈
在最后我们将探讨x86上的C语言栈.同时,我们要实现一个内核调试函数: 打印函数的调用轨迹(backtrace).

## Exercise 9
1. 确定内核在初始化栈后,栈的起始位置?
2. 内核是如何保证栈的空间的?
3. 初始化栈之后,栈又在何处结束?

---
x86的栈指针寄存器(esp)指向当前栈的最低地址,该地址以下的栈空间都是free的.当值入栈时,esp先向下移动,再将值写入esp指向的位置.当值出栈时,首先读取esp指向的值,然后将esp向上移动.在32位模式,栈中只能保存32bit数值,且esp总能被4整除.一些x86指令,比如call,是直接使用esp寄存器中的值的.

栈底寄存器(ebp)指向栈的底部.当进入一个C语言函数时,首先将前一个函数的ebp寄存器值入栈,然后当前的esp值赋给ebp.如果我们所有的函数调用都遵循这样的规则,那么在任意函数中,我们都可以回溯出函数的调用路径.当我们的程序出问题的时候,这样的回溯会对调试有非常大的帮助.

## Exercise 10
为了加深我们对C语言函数调用规则的了解,在`obj/kern/kernel.asm`中找到函数`test_backtrace`并设下断点.看看它每次被调用时发生了什么?每次被调用时,入栈了哪些参数?

上面的练习应该让你对我们要实现的stack backtrace函数有了些感觉.在`kern/monitor.c`中,6.828已经准备好了函数原型`mon_backtrace()`.`inc/x86.h`中的函数`read_ebp()`会对我们实现`mon_backtrace()`有所帮助.当我们实现之后,应该将`mon_backtrace`加入`kern/monitor.c`中的commands中,以便从命令行调用.

输出格式要求如下:
```
Stack backtrace:
  ebp f0109e58  eip f0100a62  args 00000001 f0109e80 f0109e98 f0100ed2 00000031
  ebp f0109ed8  eip f01000d6  args 00000000 00000000 f0100058 f0109f28 00000061
  ...
```

