# LEC18 Scalable Locks

## 本论文的目的
1. 论文中图2展示的场景在多核场景下简直是场灾难.
2. 锁导致性能大幅度下降,增加更多的核并没有能够提升性能.
3. 这种`non-scalable lock`现象非常重要.
4. 现象出现的原因值得探究和思考.
5. 这些解决方案是并行编程中的巧妙练习

## 核心问题
1. 问题为: 多核场景中cache缓存间,锁信息的交互.

## 多核基本场景
1. 我们已经有了基本的多核场景的模型概念.
2. 多个核之间共享总线和内存.
3. 为了实现锁获取的功能,x86的`xchg`指令会锁住总线,从而为`xchg`提供原子性.

## 实际场景
当然实际场景要复杂的多.对于CPU而言,总线和内存都是非常慢的.因此每个CPU都会拥有自己的cache缓存.

如果CPU要访问的数据位于cache中,那么只需要几个指令周期就可以完成数据读取,如果cache未命中,从内存中读取数据,往往需要100个指令周期以上.

## cache同步
既然每个CPU都有自己的cache缓存,那么如何保证每个CPU的cache的内容是正确的呢?

举个例子:
1. core 1读取变量x的值为10.
2. core 2将x的值修改为11.
3. 此时,core 1读取变量x的值为多少呢?

此时,我们需要引入缓存一致性协议(cache coherence protocal).从而保证每个CPU都可以读取到最新的写入内容.

## 缓存一致性如何运行?
1. 有许多方案,下面是个简单实现.
2. 每条cache line都有自己的状态, 地址和64字节的数据.
3. 状态包括以下三种: 已修改(Modified), 共享(Shared), 失效(Invalid)
4. 当CPU读写数据时,将会在核间交换信息.

## 简化的消息类型
1. invalidate(addr): 使得cache line失效
2. find(addr): addr上的数据是否在其他核上有拷贝.
3. 所有消息都会广播给所有核.

## 下面展示了核间如何同步?
```
  I + local read -> find, S
  I + local write -> find, inval, M

  S + local read -> S
  S + local write -> inval, M

  S + recv inval -> I
  S + recv find  -> nothing, S

  M + recv inval -> I
  M + recv find  -> reply, S
```

1. 如果已经是Shared,那么读取可以不需要bus通信.
2. 如果已经是Modified,那么写入可以不需要bus通信.

## 两个核之间可能的状态
```
		  core1
		  M S I
		M - - +
core2   S - + +
		I + + +
```

1. 对于每个cache line,最多一个核处于Modified.
2. 对于每个cache line,要么一个核为Modified,要么均为Shared,没有其他情况.

Q: 什么样的使用模式受益于这种一致性方案？

A:

1. 只读数据(每个cache都有一份数据copy)
2. 仅有一个core反复写数据(Modified提供了排他性的写入)

还有其他的可能方案,比如写入会更新其他拷贝的内容,但是失效似乎更好.

## 真实方案
1. 真实硬件使用的方案更加巧妙
2. 链路网络取代了bus总线,单播取代广播.
3. 使用分布式目录,用于跟踪哪些内核缓存每一行
4. 单播查找到目录

Q: 如果我们有了cache一致性,为什么还需要锁?
A: cache一致性保证了CPU可以读取到最新的数据,而锁避免了在读取-修改-写回循环中不丢失更新,同时避免其他人读取到操作未完成的数据.

## 开发者根据硬件提供的原子指令构建了锁
1. xv6使用了原子性的交换
2. 其他锁的实现可能利用了`test-and-set`,或者原子自增等.
3. 类似`__sync__`等函数,最终将转化为原子指令

## 硬件是如何实现原子指令的?
1. 当cache line设为Modified.
2. 推迟处理所有一致性消息
3. 完成操作(读取旧值,写入新值)
4. 恢复处理一致性消息

## 锁的性能
1. 假设同时有N个核在等待锁
2. 从前一个持有者到后一个持有者,lock额外损耗的时间是多少?
3. 性能瓶颈通常存在于核间内部通信.所以我们将根据msg的数量来衡量成本.

## 我们期待怎样的性能?
1. 假设N个核在等待.
2. 我们希望所有核总等待时间复杂度为O(N)
3. 我们希望每个临界区和损耗时间复杂度为O(1),即和参与的核数无关.
