# Homework

Q: 论文图6展示了Linux如何使用`socket option`.在只读场景下无锁访问`sock->opts`为什么是安全的?为什么读取数组旧数据是安全的,而不会读到已释放的内存.

---

问题的关键在于系统何时释放`sock->opts`对应的旧对象.写进程的`call_rcu()`只有在所有CPU core均执行一次上下文切换后,才会释放旧对象.读进程在读取前会首先禁用抢占,从而避免被动的进程调度.`rcu_dereference()`要么返回新对象,要么返回旧对象.
