# 进程, 线程和调度

## 大纲
1. 课后作业
2. 线程切换
3. 调度

---

## 课后作业
homework 9深入思考

### iderw()
1. 代码目录`xv6/ide.c`

2. `idelock`保护了什么?
    整个系统中可能存在很多进程,每个进程都可以发起ide请求,而ide驱动每次只能处理一个请求.因此需要一个`idequeue`用于缓存这些请求.如果没有`idelock`,那么缓存ide请求时就会发生竞争,导致部分ide请求永远得不到处理.同时发起请求的线程将永远处理sleep状态.

3. 在acquire之后增加sti(),在release之前增加cli(),将会发生什么?为什么?
答:  现象为可能出现`panic acquire`
    原因: 改动将导致在处理ide请求是,允许发生中断,即当前进程可以被调度.如果线程A获取idelock在core 1上,在线程A sleep之前是可能被调度出去的.如果另一个线程B此时调度到core1上运行,且同时发起了ide请求,那么就会尝试获取idelock.此时idelock处于被锁状态且idelock->cpu恰好为core 1,因此会直接panic.

4. 如果自旋锁抢锁时,没有检查锁是否已被当前core获取,会发生什么?
答:  如果没有已获取检查,设想这样一种情况,线程A运行在core 1上,且此时线程A已获取自旋锁a.若此时线程A再次尝试获取自旋锁a,那么
`while(xchg(&lk->locked, 1) != 0)`将死循环.且线程A既不会被调度也不会释放锁a.

5. 在原代码中,中断是如何发生和处理的?
答: ide操作和CPU运行速度相比要慢的多,因此这部分处理主要使用了异步处理的方式.
    对进程而言通过调用`iderw()`来将ide请求添加到`idequeue`中,然后线程将进入睡眠等待状态.
    对ide驱动依次从`idequeue`中取出ide请求,并发送给硬件,然后CPU将返回,并运行其他进程.
    当硬件完成ide请求后,将发出硬件中断`T_IRQ0 + IRQ_IDE`,并触发中断处理.中断处理将会调用`ideintr()`来读写数据,并唤醒之前睡眠的进程.若`idequeue`中还有尚未完成的请求,将向硬件发出新的请求.
    
6. 对当前代码而言,IDE中断会被发送到同一个core上.若IDE中断发生在不同的core上会如何?
提示:
    1) 阅读`spinlock.c acquire()/release()`,它们是如何控制中断的?
        `acquire()`时将会在当前core上禁用中断,然后不断轮询直至获取锁.在此期间不会被调度.
        `release()`释放锁之后,将会启用中断.
    2) 为什么要使用`pushcli()/popcli()`对中断控制进行计数?
        通过对中断控制的计数可以确保禁用和启用中断是成对出现的.不会出现预料之外的情况.比如两次`cli()`,一次`sti()`,此时中断已启用,未必符合预期.
   3)  `mycpu()->intena`表征了`pushcli`前,core是否允许中断.若调用`pushcli()`前禁用中断,那么`popcli()`也不会启用中断,不会出现
   
答: 看不出什么问题.好像在`idelock`的保护下没啥问题?

7. 为什么`acquire()`要在抢占锁之前,禁用中断?

答: 从注释来看,主要是为了避免死锁.如果未禁用中断,则表示在进入`acquire()`后,仍然可以被调度.设想这样一个场景: 线程A运行在core a上且获取了锁,线程B运行在core b上正在等待锁.此时如果线程B被调度到core a上,线程A被调度到core b上,在线程A释放锁时,线程A会panic.此时线程B将永远无法获取锁.

### filealloc()
1. 代码目录`xv6/file.c`

2. 在`filealloc()`中,如果中断启用了会怎样?
答: 中断启用表示可以进程调度,那么在`release(&ftable.lock)`会发生panic.

3. 锁`ftablc.lock`保护的什么资源?
答: 在xv6中,ftable是一个用于管理file资源的结构体,所有file资源在初始化被申请,且可以循环使用.`ftable.lock`主要就是用于保护这些file资源.

4. 即使我们修改了`filealloc()`代码,为什么通常不会出问题?
答: 之前我们已经提到过了,想要发生问题的前提是在获取锁之后,发生进程调度.但是这个窗口很小,因此大部分时候不会触发.

5. 如何使问题必现?
答: 根据前面的分析,只要在启用中断,发生进程调度即可.因此可以在`acquire()`之后,添加`yield()`,强制进程调度.

---

## 进程调度 














































---