# Part C: 进程抢占和进程间通信
在Lab4的最后部分,我们将要实现进程抢占功能以及进程间通信.

## 时钟中断和抢占
阅读代码`user/spin`.代码比较简单,创建了一个子进程,在子进程中不断循环.在当前的条件下运行该代码,我们会发现父进程或者内核都无法再运行了,因为子进程始终在用户空间死循环.显然理想的操作系统必须避免这种情况,因为开发者可能会出Bug,又或者恶意程序故意如此.为了支持内核抢占一个正在运行的用户进程,我们必须使得JOS支持外部硬件的时钟中断.

### 中断机制
外部中断(比如时钟中断),被称为IRQs.一共有16种可能的IRQs,编号为0~15.从IRQ到IDT(中断向量表)的映射不是固定的.`picirq.c`中的`pic_init()`将IRQs 0~15映射到IDT的IRQ_OFFSET-IRQ_OFFSET+15.

在`inc/trap.h`中,IRQ_OFFSET被定义为十进制32,因此IDT入口32~47对应着IRQs 0~15.如果时钟中断是IRQ 0,那么时钟中断的处理函数地址位于IDT[IRQ_OFFSET+0],即IDT[32].IRQ_OFFSET是经过精心挑选的,主要是为了使得外部中断和内部中断分别使用不同的中断号.

相对于xv6,我们对JOS做了一定的简化.在内核态时,外部中断是被禁止的,只有在用户态外部中断是启用的.通过`%eflags`寄存器中的`FL_IF`标志位来控制外部中断是否启用.当该标志置1,外部中断启用.基于我们的简化,我们可以在进入和离开用户态时,修改该标志位的值.

我们必须确保在用户态时,该标志位被置位.这样当外部中断发生时,内核才能跳转到对应的中断处理函数.除此之外,`FL_IF`应该被置0.到目前为止,我们在bootloader中禁用了外部中断,且尚未启用.

### Exercise13
1. 修改`kern/trapentry.S`和`kern/trap.c`,初始化IDT,并提供IRQs 0~15的中断处理函数.
2. 修改`kern/env.c`中的`env_alloc()`,以确保用户态进程外部中断启用.
3. 取消`sched_halt()`中的`sti`注释,使得空闲CPU相应外部中断.
4. 当调用硬件中断处理函数时,CPU生成的Trapframe和之前稍有不同,不再有error code字段.为了保持Trap frame结构体一致,我们在其中补了0.具体可参考[section 9.2](https://pdos.csail.mit.edu/6.828/2017/readings/i386/toc.htm)和[section 5.8](https://pdos.csail.mit.edu/6.828/2017/readings/ia32/IA32-3A.pdf)

### 测试
运行`user/spin`,可以发现内核打印硬件trap framee信息.虽然CPU现在启用了外部中断,但是并未正确的处理外部中断.因此此时会销毁用户进程,并进入monitor.


---

## 处理时钟中断
在`user/spin`中,子进程一旦开始运行就进入死循环,因此内核无法再获取CPU的控制权.我们需要配置硬件以定期生成时钟中断,这会使得CPU的控制权强制转移到内核.一旦内核获得了CPU控制权,就可以再次进行进程调度.

在`init.c`中,`i386_init()`调用了`lapic_init()`和`pic_init()`.设置时钟和中断控制器以产生时钟中断.

### Exercise14
修改`trap_dispatch()`,当时钟中断发生时调用`sched_yield()`,以触发进程调度.

### 测试
1. `user/spin`将可以正常运行,父进程可以被正确调度运行并最终杀死子进程.
2. 运行`user/forktree()`
3. 运行`make CPUS=2 XXX`
4. 运行`user/stresssched`
5. 运行`./grade-lab4 -v`,得分应为`65/80`

---
