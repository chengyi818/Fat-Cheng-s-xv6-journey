# 写时拷贝
正如之前提到的,Unix提供了`fork()`系统调用用于创建进程.`fork()`会拷贝父进程的地址空间到子进程的地址空间.

xv6的`dumbfork()`将会拷贝父进程地址空间中的全部内容到子进程的地址空间中.这部分数据拷贝是进程创建中耗费最多的部分.然而在创建新进程时,往往一个`fork()`函数后面会紧接着一个`exec()`.`exec()`会使用新的代码段替换子进程拷贝而来的代码段.比如在shell中,通常就是如此.在这种情况下,父进程花费大量时间拷贝的代码段毫无用处.

介于此,新的Unix利用虚拟内存,运行父子进程共享物理内存,直接一个进程实际修改共享内存.这项技术通常被称为**写时拷贝**.新的`fork()`将会拷贝父进程页表中的映射关系到子进程中,而不是拷贝其中的内容,同时需要将共享内存标记为只读.当两个进程有进程尝试对共享内存写入时,该进程将会发生`page fault`.此时,内核立刻意识到该进程正确操作一块写时拷贝页面,内核会为该进程创建一个新的可写的页面.正是通过这种方式,我们推迟了页面实际拷贝的时间点,只有到真正写入时才会执行拷贝.这种优化使得`fork()+exec()`的消耗大幅降低,在很多时候,创建进程仅仅需要拷贝一个页面即可(当前的进程栈).

在本部分,我们将会在用户空间库中,实现一个类似Unix的`fork()`.在用户空间实现`fork()`的好处在于可以保持内核尽可能的简单,且不容易出错.用户程序完全可以根据自己的需要来组合,定义自己的`fork()`实现.比如`dumbfork()`或者真正类似于Unix`fork()`.

编者按: 本质上这种思想和Unix思想一脉相承,通过提供小而简单的工具,又用户来自由组合使用.提供机制而不是策略.

---

## 用户态page fault处理
