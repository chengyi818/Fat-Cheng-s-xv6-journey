# LEC_14 Linux ext3 崩溃恢复

# 课程大纲
1. 基于日志的崩溃恢复机制

  1.1 xv6: 实时持久化,性能较弱

  1.2 ext3: 非实时持久化,性能较好

2. 体会一种在性能和安全之间的权衡

# 举例说明
1. 本例子用于说明崩溃恢复的必要性
2. 在向文件追加内容的时候,我们需要做两步操作.
3. 首先,在bitmap中标记block为non-free
4. 其次,将block-num添加到inode的addrs[]数组中
5. 这两步操作必须是原子的,因此我们不能一次文件系统读写只做一步.

# 日志的必要性
1. 为了在系统崩溃时,保证操作的原子性.
2. 提供了文件系统快速恢复功能,而不是使用类似fsck的工具来全磁盘扫描修复.

# xv6日志系统回顾
1. 组成部分: cache, 磁盘log系统, 磁盘文件系统
2. 每个系统调用都是一个事务
3. 系统调用会修改内存中缓存的block
4. 在系统调用结束时会做以下动作:

  4.1 将修改过的block内容保存到磁盘的block区

  4.2 将修改过的block编号和一个`done`标记写入到log区

  4.3 将修改过的磁盘内容写入到磁盘真正的文件系统中

  4.4 如果在4.3写入中途发生崩溃,则可以从log区重新读取写入.

  4.5 必须保证在4.1和4.2完成后,才开始4.3的操作,从而保证了操作的原子性

  4.6 当4.3完成后,将log区中的`done`标记擦除,表示一次完整的事务提交已经完成.

# LEC_13 homework
请参见`LEC_13/homeworkd.md`

# xv6日志系统的缺陷: 缓慢
1. 在每次系统调用后,都会立刻commit.
2. 在每次commit之后,都会立刻写入文件系统.

  2.1 为什么必须立刻写入文件系统呢?因为log区仅能保存一次事务

3. 在commit时,所有文件系统相关的系统调用都会阻塞,因此并发情况下,性能很差.

4. 所有block内容都要写入磁盘两次,一次写入log区,一次写入真正的文件位置.

5. 对于小文件而言,写入两次还好.但是大文件如果写入两次,性能损耗比较大.
6. xv6所有文件写入都是同步的,xv6会等待写入完成,再继续后面的操作.
7. 创建一个空文件就需要6次同步磁盘写入,耗时约60ms.
8. 每秒钟只能执行大概10~20个文件系统相关的系统调用

---

# Linux's Ext3 背景
1. ext3是基于ext2发展的,主要是在ext2的基础上增加了日志功能
2. ext3有许多模式,我们主要介绍`journaled data`.在此模式下,日志系统同时包含元数据和文件内容数据


# Ext3结构
1. 内存中:

  1.1 block缓存

  1.2 每个事务信息: 已被日志记录的block编号集合, 尚未完成的系统调用计数器

2. 磁盘上:

   2.1 文件系统

   2.2 循环的log区

# Ext3 log区结构
1. log superblock: 保存了日志的偏移以及第一个有效事务的序号等信息
2. descriptor blocks: magic number, 事务序号, block-nums
3. data blocks
4. commit blocks: magic, 序号
5. `|super: offset+seq #| ... |Descriptor 4|...blocks...|Commit 4| |Descriptor 5|...`

# Ext3性能提升原因
## 定时提交
不再是每个系统调用提交一次,而是每过一段时间提交一次,所以每次事务都会包含许多系统调用

## 为什么定时提交能提升性能?
1. 每次事务提交都会有些固定消耗,比如陷入内核等,这些开销被分摊了
2. 段时间内,许多系统调用会重复修改同一block,这些修改最终被聚合为一次写入
3. 提升了并发性能,不必等待前一次文件系统操作commit完成,即可开始下一个文件系统操作.

# 备注
1. Ext3中,系统调用返回到用户空间时,文件系统并不能保证内容安全.
2. 这可能会影响到应用层面的一些崩溃恢复.
3. 比如: 邮件服务器接收到消息,并将消息保存到磁盘,然后向客户端回复OK.其实邮件内容还是可能丢失的.

# Ext3文件系统并发调用
1. 磁盘的log区可能已经保持了部分完整commit的事务,正等待install
2. 一些事务正在commit
3. 一个尚未完成的事务,正在接受新的系统调用.

# Ext3 文件系统调用伪码
```
  sys_open() {
    h = start()
    get(h, block #)
    modify the block in the cache
    stop(h)
  }
```

## start()
1. 告知日志系统将之后的文件系统操作视为一个事务,直到`stop()`
2. 日志系统必须知道哪些系统调用属于同一个事务,在事务完成前,不能把他们提交到日志系统
3. 如果需要,`start()`可能阻塞

## get()
1. 告知日志系统,我们修改了某个缓存的block,日志系统需要记录已修改的block
2. 在一次事务完成前,阻止将已修改的block内容写入到磁盘

## stop()
1. `stop()`不能触发一次`commit()`
2. 必须等到所有相关的系统调用都调用了`stop()`之后,事务才可以提交

# 将一个事务提交到磁盘
1. 阻塞新的系统调用
2. 等待正在处理中的文件系统操作调用`stop()`
3. 创建一个新的事务,恢复新的系统调用执行
4. 将descriptor和block编号列表写入磁盘log区
5. 将block内容从缓存写入到磁盘log区
6. 等待所有的log写入完成
7. 写入事物已commit标记位
7. 将已提交的数据,install到真正的磁盘位置

# 系统调用B能否读到系统调用A修改后,尚未commit的内容?








































---
